# RFC-0008 — Orchestrator Workflow Rules

## Status
Draft — v1.0

## Purpose
This RFC formally defines the **Orchestrator Layer (L5)** of IntentusNet.  
While the Router (L4) handles agent selection and fallback, the **Orchestrator** coordinates *multi-step, multi-agent workflows* including:

- Sequential execution  
- Parallel execution  
- Branching logic  
- Decision-making  
- Aggregation of results  
- Error recovery workflows  
- Human-in-the-loop (future)  

This layer transforms IntentusNet from simple routing into a *true multi-agent workflow engine*.

---

# 1. Goals

The orchestrator must:

- Model workflows declaratively or programmatically  
- Support arbitrary multi-step pipelines  
- Enable agents to call other agents (agent → agent)  
- Support retries & fallback at workflow level  
- Maintain workflow state & memory  
- Expose a predictable execution model for SDKs  
- Remain language-agnostic  

---

# 2. Orchestrator Definition Model

An Orchestrator Agent is a special agent with the capability:

```
intent: runWorkflow
```

But in practice, orchestrators can define *multiple workflows*.

### 2.1 Workflow Definition Schema

```json
{
  "workflowId": "string",
  "steps": [
    {
      "id": "step1",
      "type": "task|parallel|branch|wait",
      "intent": "optional",
      "agent": "optional",
      "input": { },
      "next": ["step2"]
    }
  ],
  "onError": "fail|continue|retry|fallback",
  "maxRetries": 1
}
```

### 2.2 Execution Types

| Type        | Behavior |
|-------------|----------|
| `task`      | Runs a single agent synchronously |
| `parallel`  | Runs multiple intents concurrently |
| `branch`    | Chooses next step based on rule |
| `wait`      | Pause or wait for external signal |

---

# 3. Runtime Behavior of Orchestrator

Workflow execution is stateful:

```
context.memory
context.history
context.sessionId
context.workflowId
```

### Execution Flow:
1. Orchestrator receives `processDocument` (or any workflow intent)  
2. Loads workflow spec  
3. Executes steps in order  
4. Each step invokes router → agent  
5. Aggregates results  
6. Returns final response to client  

The orchestrator MUST leverage:

- router for routing  
- fallback logic  
- trace system  
- EMCL envelope when enabled  

---

# 4. Agent-to-Agent Calls (A2A)

Agents may call other agents through the router:

```
self.call_agent("summarizer", intent="summarizeDocument")
```

Orchestrator supports:

- synchronous chaining  
- parallel fan-out  
- cascading fallback  
- grouped results  

Example:

```
summary = call("summarizer")
labels = call("classifier")
storage = call("primaryStorage") or fallback("secondaryStorage")
```

---

# 5. Error Handling Model

### 5.1 Step-Level Failures
Each step can define:

- `retry`
- `fallback`
- `skip`
- `fail`

### 5.2 Workflow-Level Failure Modes

| Mode       | Description |
|------------|-------------|
| `fail`     | Entire workflow stops |
| `retry`    | Retry entire workflow |
| `continue` | Skip failed steps |
| `fallback` | Use alternative workflow |

---

# 6. Parallel Workflow Semantics

A `parallel` step must:

- Dispatch N intents simultaneously  
- Await all results  
- Mark individual statuses  
- Fail or continue based on `onError` behavior  

Example:

```json
{
  "id": "analyze",
  "type": "parallel",
  "tasks": [
    { "intent": "summarizeDocument" },
    { "intent": "classifyDocument" }
  ]
}
```

---

# 7. Branching Rules

A `branch` step chooses next step based on:

- agent output  
- context.memory  
- payload fields  

Example:

```
if labels include "urgent":
    next = escalated-storage
else:
    next = normal-storage
```

---

# 8. Final Response Assembly

After workflow runs:

- Every step output is available in `context.memory`  
- Final orchestrator output = structured JSON combining selected results  
- Must include traceId  
- Must NOT include sensitive EMCL payloads  

---

# 9. Example: Full Multi-Agent Workflow

```
Input → Orchestrator
 → summarizeDocument
 → classifyDocument
 → storeDocument (primary → fallback → secondary)
 → secureMetadata
 → notifyUser
Output → client
```

Illustrated Timeline:

```
summarizer ────────┐
classifier ───────┐│
primary ----X──────││  (fallback triggered)
secondary ─────────┘│
secureStorage ──────┘
notification ───────┘
```

---

# 10. Tracing Integration

Each workflow step produces:

- Orchestrator span  
- Child agent spans  
- Optional router spans  

Trace relationships:

```
Orchestrator Span
  → Router Span
     → Agent Span
  → Router Span (fallback)
     → Agent Span
```

---

# 11. EMCL Workflow Semantics

If EMCL is enabled:

- All workflow payloads between orchestrator and agents MUST be encrypted  
- Orchestrator MUST NOT log decrypted content  
- Sensitive metadata must be masked in traces  

---

# 12. Future Enhancements

- Declarative YAML workflow definitions  
- Visual workflow builder  
- Graph-based execution engine  
- Human-in-the-loop approval gates  
- Long-running workflows with pause/resume  
- SLAs and workflow-level QoS controls  
- Planner engine for dynamic intent routing  

---

# 13. Conclusion

The orchestrator elevates IntentusNet from a routing system to a **true multi-agent workflow engine** with:

- agent chaining  
- decision logic  
- parallel execution  
- fallback  
- secure multi-step processing  

This RFC defines the execution foundation for enterprise automation workflows powered by distributed AI agents.

Implementation Status:
- Core Features: Implemented
- Extended Features: Roadmap (not yet available)

